#!/usr/bin/env bash

declare -A ENV
REPOS=()
declare -A URL
declare -A BRANCH
declare -A COMMIT

while [ $# -gt 0 ] ; do
  case $1 in
    -u | --update) UPDATE=true ;;
  esac
  shift
done

(
  cd "$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
  cd ..
  while IFS== read -r key value; do
    if [[ $key == '' || $value = '' || $key =~ ^[[:space:]]*#.*$ ]]; then
      continue
    fi
    ENV[$key]=$value
  done < ".third_party"
  for key in "${!ENV[@]}"; do
    REPOS+=(${key%_*})
    declare -n array=${key##*_}
    declare -n value=$key
    array[${key%_*}]=${value:-${ENV[$key]}}
    unset -n array
  done
  REPOS=($(printf "%s\n" "${REPOS[@]}" | sort -u))
  THIRD_PARTY=$(mktemp)
  (set -x && mkdir -p third_party)
  for REPO in ${REPOS[@]}; do
    (
      cd third_party
        (
          DIR=$(TMP=${URL[$REPO]##*/};echo ${TMP%.*})
          if [[ ! -d $PATH ]]; then (set -x && mkdir -p $DIR); fi
          cd $DIR
          if [[ $(git rev-parse --git-dir 2> /dev/null) != '.git' ]]; then
            (set -x && git clone -j8 ${URL[$REPO]} .)
          fi
          (set -x && git fetch)
          (set -x && git reset --hard)
          (set -x && git submodule foreach --recursive git reset --hard)
          if [[ $UPDATE || -z ${COMMIT[$REPO]} ]]; then
            (set -x && git checkout -B ${BRANCH[$REPO]} origin/${BRANCH[$REPO]})
          else
            (set -x && git checkout ${COMMIT[$REPO]})
          fi
          (set -x && git submodule update --init --recursive)
          echo "${REPO}_URL=${URL[$REPO]}" >> $THIRD_PARTY
          echo "${REPO}_BRANCH=${BRANCH[$REPO]}" >> $THIRD_PARTY
          echo "${REPO}_COMMIT=$(git rev-parse --short HEAD)" >> $THIRD_PARTY
          if [[ ${REPOS[-1]} != $REPO ]]; then
            echo "" >> $THIRD_PARTY
          fi
        )
    )
  done
  set -x
  cat $THIRD_PARTY > .third_party
  rm $THIRD_PARTY
)
