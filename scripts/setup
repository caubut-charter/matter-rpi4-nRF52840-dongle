#!/usr/bin/env -S bash -euET -o pipefail -O inherit_errexit

declare -A THIRD_PARTY
REPOS=()
declare -A URL
declare -A BRANCH
declare -A COMMIT

UPDATE=false

while [ $# -gt 0 ] ; do
  case $1 in
    -u | --update) UPDATE=true ;;
  esac
  shift
done

(
  cd "$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
  cd ..
  while IFS== read -r KEY VALUE; do
    if [[ $KEY == '' || $VALUE = '' || $KEY =~ ^[[:space:]]*#.*$ ]]; then
      continue
    fi
    THIRD_PARTY[$KEY]=$VALUE
  done < ".third_party"
  for KEY in "${!THIRD_PARTY[@]}"; do
    REPOS+=(${KEY%_*})
    declare -n ARRAY=${KEY##*_}
    declare -n VALUE=$KEY
    ARRAY[${KEY%_*}]=${VALUE:-${THIRD_PARTY[$KEY]}}
    unset -n ARRAY
  done
  REPOS=($(printf "%s\n" "${REPOS[@]}" | sort -u))
  THIRD_PARTY=$(mktemp)
  (set -x && mkdir -p third_party)
  for REPO in ${REPOS[@]}; do
    (
      cd third_party
        (
          DIR=$(TMP=${URL[$REPO]##*/};echo ${TMP%.*})
          if [[ ! -d $PATH ]]; then (set -x && mkdir -p $DIR); fi
          cd $DIR
          if [[ $(git rev-parse --git-dir 2> /dev/null) != '.git' ]]; then
            (set -x && git clone -j8 ${URL[$REPO]} .)
          fi
          (set -x && git fetch)
          (set -x && git reset --hard)
          (set -x && git submodule foreach --recursive git reset --hard)
          if [[ $UPDATE = true || -z ${COMMIT[$REPO]} ]]; then
            (set -x && git checkout -B ${BRANCH[$REPO]} origin/${BRANCH[$REPO]})
          else
            (set -x && git checkout ${COMMIT[$REPO]})
          fi
          (set -x && git submodule update --init --recursive)
          echo "${REPO}_URL=${URL[$REPO]}" >> $THIRD_PARTY
          echo "${REPO}_BRANCH=${BRANCH[$REPO]}" >> $THIRD_PARTY
          echo "${REPO}_COMMIT=$(git rev-parse --short HEAD)" >> $THIRD_PARTY
          if [[ ${REPOS[-1]} != $REPO ]]; then
            echo "" >> $THIRD_PARTY
          fi
        )
    )
  done
  set -x
  cat $THIRD_PARTY > .third_party
  rm $THIRD_PARTY
)
